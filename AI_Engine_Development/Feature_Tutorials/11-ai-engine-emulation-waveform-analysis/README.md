<table>
 <tr>
   <td align="center"><img src="https://www.xilinx.com/content/dam/xilinx/imgs/press/media-kits/corporate/xilinx-logo.png" width="30%"/><h1>AI Engine Versal Emulation Waveform Analysis</h1>
   </td>
 </tr>
 <tr>
 </td>
 </tr>
</table>

# Introduction
Simulating a complete system in Vitis allows for a near-hardware run of a design without the hardware, and has added benefit of detailed waveform analysis during hardware emulation to identify issues in the programmable logic, AI Engine interfaces, and memory read/writes that could be harder to figure out on hardware.

This tutorial will demonstrate how you can use XSIM waveform GUI, and Vitis Analyzer to debug and analyze your design for a Versal ACAP device. It will step through the process of building a design for hardware emulation, launching emulation with waveform viewing, and detailed information on how to read the waveforms, as well as, using Vitis Analyzer to continue the analysis with generated trace output waveforms and data. 
 
It is strongly recommended to go through the **Versal Integration Tutorial** and the **Advanced Versal Clocking Tutorial** before running this tutorial.

**IMPORTANT**: Before beginning the tutorial make sure you have read and followed the *Vitis Software Platform Release Notes* (v2021.1) for setting up software and installing the VCK190 base platform. 

Before starting this tutorial run the steps below:

1. Set up your platform by running the `xilinx-versal-common-v2021.1/environment-setup-aarch64-xilinx-linux` script as provided in the platform download. This script sets up the `SDKTARGETSYSROOT` and `CXX` variables. If the script is not present, you **must** run the `xilinx-versal-common-v2021.1/sdk.sh`.
2. Set up your `ROOTFS`, and `IMAGE` to point to the `xilinx-versal-common-v2021.1` directory.
3. Set up your `PLATFORM_REPO_PATHS` environment variable based upon where you downloaded the platform.

# Objectives
After completing this tutorial you should be able to:
* Use XSIM as a live waveform viewer to view signals to and from the AI Engine including stream data and RTP (Runtime Parameter)
* Read/understand Transaction Level Modeling (TLM) information in a waveform
* Utilize Vitis Analyzer to read trace and profile data
# Tutorial Overview

## Design Overview
The design is a simple FIR filter that will take in random noise generated by the programmable logic (PL) kernel **random_noise**, and have Run Time Parameter (RTP) updates asynchronously to the AI Engine to update the FIR filter coefficients. To confirm the coefficients are applied, the host code will read back the coefficients.

![Block Diagram](./images/design_block_diagram.png)

## TLM (Transaction Level Modeling)
This is modeling CIPS, NoC, and AI Engine blocks, using SystemC, to show transaction level communication in the waveform. It is cycle approximate modeling. It can provide high-level information, like the address, and data.

In the diagram below, the CIPS, NoC, and AI Engine are modeled in SystemC.

![Model Block Diagram](./images/model_block_diagram.png)

# Steps

**Step 1**: Building the Design

**Step 2**: Launching Emulation with XSIM Waveform GUI

**Step 3**: Using XSIM Waveform GUI & QEMU

**Step 4**: Using Vitis Analyzer

## Step 1: Build Design
To build the design, 

1. To build the design you'll run the following commands:

    ```bash
    make aie
    ```

After the ADF Graph is compiled, you'll run the `aiesimulator` to get additional profile data. This ensures the design is simulating correctly, and to generate extra profile information for performance analysis and optimizing the kernels.

1. To do this run:

    ```bash
    make aiesim
    ```

After running emulation a new directory, `aiesimulator_output`, is created and has a file `aiesim-options.txt` generated in it.

1. Open the `aiesim-options.txt` and you should see content like this:

  ```
  AIE_PKG_DIR=/path/to/<tutorial>/./Work
  AIE_DUMP_VCD=tutorial
  AIE_PROFILE=All
  ```

  Close the text file.

  **NOTE**: To view all the `aiesim_option.txt` values, see [Simulator Options for Hardware Emulation](https://www.xilinx.com/html_docs/xilinx2021_1/vitis_doc/simulate_graph_application.html#ilk1591226013297).

2. Run the rest of the build process running the following commands:

  ```bash
  make kernels
  make xclbin
  make host
  make package
  ```

## Step 2: Launching Emulation with XSIM Waveform GUI
After building and packaging of the design is complete you'll be able to run hardware emulation on your design. If you navigate into the `sw` directory and do an `ls launch_hw_emu.sh` and you'll see that it exists. To use the

1. To launch emulation with the XSIM Waveform GUI you'll run this command:

  ```bash
  ./launch_hw_emu.sh -g -aie-sim-options ../aiesimulator_output/aiesim_options.txt
  ```

  OR

  ```bash
  make run_emu
  ```

  In the terminal you'll see:

  ```log
  Starting QEMU
  - Press <Ctrl-a h> for help 
  Waiting for QEMU to start. 
  running directly on console
  QEMU started. qemu_pid=3208
  Waiting for PMU to start. 
  qemu-system-aarch64: -chardev socket,path=./qemu-rport-_pmc@0,server,id=ps-pmc-rp: info: QEMU waiting for connection on: disconnected:unix:./qemu-rport-_pmc@0,server
  PMC started. pmc_pid=3243
  qemu-system-aarch64: -chardev socket,id=pl-rp,host=127.0.0.1,port=7043,server: info: QEMU waiting for connection on: disconnected:tcp:127.0.0.1:7043,server
  XSIM started. xsim_pid=3300
  ```

  This is QEMU starting and launching XSIM. Take note that QEMU and XSIM are linked together, meaning closing one will close the other. Since the `-g` flag is used, it'll open up the XSIM Waveform GUI as shown below:

  ![XSIM GUI Startup](./images/xsim_gui_startup.png)

  Here you can select what signals you want to watch from the **Scope** and **Objects** views. 

2. This file will remove any default signals provided by the simulation environment, and add in all the signals you want to view. There are some signals that are important to have such as: NoC, DDR, PL Kernel, and CIPS signals. Your design interacts with these components, and being able to trace signal changes from CIPS to the NoC to/from DDR, and then to your design can prove helpful in debugging any potential issue with data transfers. In the **Tcl Console** at the bottom of the view, run the following command:

  ```Tcl
  source ../../../../tcl/add_waveforms.tcl
  ```

  This file contains the following:

  ```Tcl
  # Remove all waveforms before adding new ones
  remove_wave -of [get_wave_config] [get_waves -of [get_wave_config] -regexp ".*"]

  # Set the appropriate paths based upon the platform being used
  set scope_path "/xilinx_vck190_es1_base_wrapper_sim_wrapper/xilinx_vck190_es1_base_wrapper_i/xilinx_vck190_es1_base_i"

  # Create a wave group called CIPS and add all signals for the CIPS_0 to it
  set CIPS [add_wave_group CIPS]
  set cips_intf [get_objects -r $scope_path/CIPS_0/* -filter {type==proto_inst}]
  add_wave -into $CIPS $cips_intf

  # Create a wave group called NOISE and add all signals of the random_noise_1 to it
  set NOISE [add_wave_group NOISE]
  set noise_intf [get_objects -r $scope_path/random_noise_1/* -filter {type==proto_inst}]
  add_wave -into $NOISE $noise_intf

  # Create a wave group called S2MM and add all signals of the S2MM kernel to it
  set S2MM [add_wave_group S2MM]
  set s2mm_intf [get_objects -r $scope_path/s2mm_1/* -filter {type==proto_inst}]
  add_wave -into $S2MM $s2mm_intf

  # Create a wave group called CIPS_NOC and all signals of the CIPS NoC to it
  set CIPS_NOC [add_wave_group CIPS_NOC]
  set cips_intf [get_objects -r $scope_path/cips_noc/* -filter {type==proto_inst}]
  add_wave -into $CIPS_NOC $cips_intf

  # Create a wave group called DDR4 and all signals to/from DDR4
  set DDR4 [add_wave_group DDR4]
  set ddr4_intf [get_objects -r $scope_path/noc_ddr4/* -filter {type==proto_inst}]
  add_wave -into $DDR4 $ddr4_intf

  # Create a wave group called AIENGINE and all signals of the AI Engine block to it
  set AIENGINE [add_wave_group AIENGINE]
  set aie_intf [get_objects -r $scope_path/ai_engine_0/* -filter {type==proto_inst}]
  add_wave -into $AIENGINE $aie_intf
  ```

  **NOTE**: This file can be executed automatically from the `launch_hw_emu.sh` command by using the `-user-pre-sim-script add_waveforms.tcl`.

  **IMPORTANT**: Add all the signals you need before starting emulation. Starting emulation, and pausing it to add more signals will not yield any data for the new signals, and you will have to restart emulation.

  You will see a waveform view as follows:

  ![XSIM with new signals](./images/xsim_with_signals.png)

3. Expand the all signal groups in the view to get a view like this:

  ![Expanded signals](./images/expanded_signals.png)

4. The tutorial design runs very fast and you won't be able to see anything meaningful with the scale this small. Adjust the scale to 100us:
   
   ![Proper Scale](./images/proper_scale.png)

   **TIP**: The scale can be adjusted when emulation is running to fit your needs.

**NOTE**: For more information about this simulator view and how to use it, read [UG900 Vivado Design Suite User Guide: Logic Simulation](https://www.xilinx.com/support/documentation/sw_manuals/xilinx2021_1/ug900-vivado-logic-simulation.pdf)
## Step 3: Using XSIM Waveform GUI & QEMU
A great benefit of having a waveform viewer showing live data is so you can see how the signals will interact with each other. This includes the programming of the AI Engine and device, traffic to/from the DDR, traffic to/from PL kernels, as well as seeing Real-Time Parameters (RTP) being written to the AI Engine.

1. Click the **Run All** button (![run all](./images/run_all.png)). 

1. Click back to the terminal where **./launch_hw_emu.sh** was launched. You will notice that the QEMU instance has begun booting and when you see the following messages QEMU will have finished launching.

  ```text
  root@versal-rootfs-common-2021_1:~# Enabling notebook extension jupyter-js-widgets/extension...
      - Validating: OK
  xinit: giving up
  xinit: unable to connect to X server: Connection refused
  xinit: server error
  [C 17:53:36.686 NotebookApp] Bad config encountered during initialization: No such notebook dir: ''/usr/share/example-notebooks''
  ```
  **IMPORTANT**: Ignore the messages above.

5. Hit **Enter** a few times to clear these messages and you should see this prompt:

  ```bash
  root@versal-rootfs-common-2021_1:~#
  ```

6. Type in the following commands to launch the tutorial application:

  ```bash
  export XILINX_XRT=/usr
  cd /mnt/sd*1
  ./host.exe a.xclbin
  ```

  **NOTE**: This may take some time to complete since hardware emulation is collecting profiling data as well as VCD data.

7. Navigate back to the XSIM Waveform GUI and you should start noticing signals are toggling. Scroll up and down to see all the signals that are starting to display data.

8. Pause the execution of the design when you see all signals in the view stop toggling. 

### Exploring the waveforms
One of the things the waveform viewer can help with is figuring out the order in which data is transferred from a source to a destination. In the sections below you'll explore the various waveforms specific to certain communication/data transfer.

**NOTE**: If AI Engine kernels contain `printf` statements, the output will show up in the XSIM Waveform GUI in the **Tcl Console** and will be written to the `simulate.log` file after emulation is closed.

#### **Checking Proper Boot-up via PMC**
The first key step to making sure emulation is operating correctly is making sure that the PS is able to program the platform management controller (PMC). This system is responsible for booting and configuring the device. Seeing the signal through the CIPS, NoC, and AI Engine is a sign that things are operating normally. 

1. To see this signal only run the following Tcl script:

  ```tcl
  source ../../../../tcl/bootup_signals.tcl
  ```

  ![Bootup Signals](./images/bootup_signals.png)

2. Zoom in to the first toggle by clicking and dragging the mouse from the upper left to the bottom right. You should see something like the following:

  ![Bootup Zoomed In](./images/bootup_zoom_in.png)

  Expand these signals and dig into how these signals are displayed. These signals are TLM, because the blocks of the device they are targeting are modeled in SystemC. Another thing to remember is, a wide colored block may not be one transaction (remember, you're in a ***us*** timescale), so zoom in and notice there are more transactions occurring is such a short amount of time.

  <!-- How do we know when it fails to program? -->

3. Zoom the window to full by clicking the mouse on the lower right side, and drag to the upper left.

#### **PL to AIE**
After bootup and the device is configured, the application can begin to run. In this design, there's a PL Kernel called ***random noise*** that is generating data that is being fed directly into the AI Engine. The key here is looking at the ***s_axi_control*** interface to see when the PS will send the "run" signal.

10. To view the specific signals controlling the PL kernel, run:

  ```tcl
  source ../../../../tcl/pl_to_aie.tcl
  ```

  You will need to zoom into a specific region. In the screenshot below the red area is the zoom region.

  ![Zoom region](./images/pl_to_aie_zoom_region.png)

  After that zoom in, you should see something similar to this:

  ![Zoomed in](./images/pl_to_aie_zoomed_in.png)

  Here you can see the PS is using the ***FPD*** (Full Power Domain) interface to send the AXI signal to turn on. Notice that there's two blocks shown. This is actually the PS telling the ***random_noise*** and ***s2mm*** kernels to turn on.

  If you zoom in more, you can see more specifics of the transactions.

  ![Zoomed in 2x](./images/pl_to_aie_zoom_2x.png)

  Notice that the **s_axi_control** has a read transaction slightly after the second transaction of the ***FPD*** interface.

11. Make sure to expand the ***M_AXI_FPD_tlm*** interface and the ***Outstanding Reads*** and you will see a ***Row 0***. If you move the mouse over the **#3** or **#4** a context help menu will show up to show you some signal information of where data is being transfer. Notice the **ARADDR** value of 0xa4060000 and for **#3** and 0xa4050000 for **#4**, and understand that this is the address to the PL kernels that `v++` auto-assigns it during linking. From the host code, you can determine that these kernels are activated before the AI Engine, and soon after the application starts, so it is safe to say these signals are used to start them. Do remember that these kernels are far more simple than others, and more complex kernels may see different transactions happen.

12. Zoom to fit when done by clicking the **Zoom Fit** button (![zoom fit](./images/zoom_to_fit.png)).
    
#### **AIE RTP Signals**
As mentioned in the **Overview** this design is sending RTP values to the AI Engine through `graph.update()`. From the host code, you can see that there are two updates being done with both being an array size of 12. Since these only apply to the AI Engine kernel, these will write signals to the AI Engine **S00_AXI** interface. However, there are other signals that show the same values because these are the interfaces the data traverses to the destination.

13.  Run the following Tcl script to see only the AI Engine signal:
    ```tcl
    source ../../../../tcl/rtp_signals.tcl
    ```

14. Expand the **ai_engine_0_0_S00_AXI** interface, and expand the **Outstanding Writes**. You will see a bunch of write transactions, and go to the second visible instance shown below:
  
    ![RTP zoom loc](./images/rtp_zoom_loc.png)

15. Zoom into the first group of writes until you can see something like the screenshot below.  
    
    ![RTP Signals](./images/rtp_signals.png)

    **NOTE**: The waveform you have may not look exactly like this. This is because of the model and it being approximately timed.
    
    Here you can see that there are 12 writes that are being sent to the AI Engine which are the RTP coefficients that are to be updated in the design. Since these are asynchronous commands, the exact timestamp when it executes is indeterministic.

    **TIP**: There are two RTP updates occurring. If you follow the same write signal, you will find the write transactions for the second update.

16. Click the **Zoom to Fit** button when done.
#### **AIE to DDR**
After the RTP update has been sent, you can start to see output data being written to DDR. In this design, the AI Engine is sending data from the **S00_AXIS** interface and getting it to the ***s2mm*** kernel. This kernel is a FIFO written in HLS and is used to write the output to DDR. As you can see, various writing of data to DDR is happening. 

17. To view these signals run: 

    ```tcl
    source ../../../../tclaie_to_ddr.tcl
    ```

    You should see something like this:

    ![AIE to DDR](./images/aie_to_ddr.png)

    As you can see, the transactions in green are slightly ahead of the tan. This means those signals are going first, and the **M00_AXI** and the **s** interfaces are matched, meaning they are connected together. Same with the **m_axi_gmem** and the **S00_AXI**. 

After the data is stored into DDR, the host application will then be able to access it.

18.  Once emulation is done, you can close the XSIM GUI, which will close QEMU and the emulation. Discard the waveform when the pop-up occurs.
19.  Navigate back to the terminal that launched emulation.

#### **Limitations**
A few limitations to the waveform viewer:
- Signals internal to the AI Engine can be viewed using VCD -- similar to how it is done in `aiesimulator`. They are not visible in the general XSIM Waveform GUI.
- CIPS (QEMU model) which executes the software program is purely a functional model with no accuracy for timing. The NoC, DDR, and AI Engine are cycle approximate models.
- Bandwidth and latency estimation are approximate based on the accuracy of the individual IP models.

## Step 4: Using Vitis Analyzer
After emulation is complete, you can look at the profiling and VCD Trace data that was also being processed at the same time. Do note, if profiling and VCD signal capturing are not used, emulation will run faster.

Using the XSIM Waveform GUI to view waveforms is powerful in allowing you to see the data path and flow of the design, as well as debug potential issues like a hang. However, this will only show the programmable logic side of issue and will not be as helpful if the issue is in the AI Engine. Vitis Analyzer can be used to dig into the design more for more debugging. For this design, everything from the system side is working, and you want to see the trace and VCD ADF Graph. To use Vitis Analyzer, you will need to open up a `.aierun_summary` file.

1. Open the run summary of the design by running the following command:

   ```bash
   vitis_analyzer sw/sim/behav_waveform/xsim/default.aierun_summary &
   ```
  
    Once the summary is open, you should see something similar to this screenshot:

    ![Vitis Analyzer Summary](./images/vitis_analyzer_summary.png)

2. Here you will see various reports: **Summary**, **Trace**, **Profile**, **Graph**, **Array**. Click on **Trace** to open up the VCD data that was collected during hardware emulation.
   
   ![Vitis Analyzer Trace](./images/vitis_analyzer_trace.png)

Here you can see the inner traces of the graph through a tile hierarchy. Selecting a net, tile, function, or any object in this view will cross-select to various views. This can help with identifying certain nets and functions. 

1. The RTP signals are of interest, but don't know exactly which ones they are. Open the **Graph** view and click on the **Buffers** tab.
2. To find the RTP buffers, click on the search button (![search](./images/search.png)) and type in `coeffs`.

    You should see a window like the following:
    
    ![rtp search](./images/graph_buffers.png)

3. Select the 3 `coeffs` buffers, and click on the **Trace** view again, and see that the lock signals are highlighted.

    ![Selected RTP](./images/selected_rtp.png)


4. If you scroll up you can see that the FIR filter kernel begins to process data soon after the RTP is read.

5. Open up the **Profile** report and see specific information about the kernel and the tile it is placed in.

    ![Vitis Analyzer Profile](./images/vitis_analyzer_profile.png)

6. Click on **Total Function Time** and see the following:

    ![Total Function Time](./images/profile_total_time.png)

    Having this information is useful since it help determine how long the kernel runs and can be used with the **Trace** to help determine if kernels are running optimally, or if there are stalls.
    
7. Close Vitis Analyzer.
# Summary
Over the course of this tutorial you have learned:
- To read the waveform viewer to follow data flow pathing for a simple Versal design
- To add/remove signals to the XSIM to look at specific signals like: NoC, DDR, PS, AI Engine
- View TLM signals and how they interact with the AI Engine and Versal blocks
